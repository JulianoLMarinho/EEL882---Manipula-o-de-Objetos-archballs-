<!DOCTYPE html>
<html lang="en">

<head>
    <title>ARCBALLS</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        body {
            background-color: #f0f0f0;
            color: #444;
        }

        a {
            color: #08f;
        }
    </style>
</head>

<body>


    <script src="js/three.js"></script>

    <script src="js/DragControls.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/BufferGeometryUtils.js"></script>


    <script>


        var container, stats;
        var camera, controls, scene, renderer, dragControls;
        var objects = [];
        var objectsR = new THREE.Group();
        let sphere = new THREE.SphereGeometry(50, 32, 32);
        let material = new THREE.MeshLambertMaterial({ color: Math.random() * 0x000 })
        let t = new THREE.Mesh(sphere, material);
        t.visible = false;
        material.transparent = true;
        material.opacity = 0.3;
        var selectedObject = null;
        var selectedObjectToDrag = null;
        var plane = null;
        init();
        animate();
        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.z = 1000;
            scene = new THREE.Scene();
            plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(5000, 5000, 8, 8), new THREE.MeshBasicMaterial({color: 0xffffff, opacity: 0.0, transparent:true}));
            //plane.visible = false;
            scene.add(plane);
            scene.add(objectsR);
            scene.add(t);
            scene.background = new THREE.Color(0xf0f0f0);
            scene.add(new THREE.AmbientLight(0x505050));
            var light = new THREE.SpotLight(0xffffff, 1.5);
            light.position.set(0, 500, 2000);
            light.angle = Math.PI / 9;
            light.castShadow = true;
            light.shadow.camera.near = 1000;
            light.shadow.camera.far = 4000;
            light.shadow.mapSize.width = 1024;
            light.shadow.mapSize.height = 1024;
            scene.add(light);
            var geometry = new THREE.BoxBufferGeometry(40, 40, 40);
            for (var i = 0; i < 20; i++) {
                var object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                object.position.x = Math.random() * 500 - 500;
                object.position.y = Math.random() * 500 - 500;
                object.position.z = Math.random() * 500 - 500;
                object.rotation.x = Math.random() * 2 * Math.PI;
                object.rotation.y = Math.random() * 2 * Math.PI;
                object.rotation.z = Math.random() * 2 * Math.PI;
                object.scale.x = Math.random() * 2 + 1;
                object.scale.y = Math.random() * 2 + 1;
                object.scale.z = Math.random() * 2 + 1;
                //object.castShadow = true;
                //object.receiveShadow = true;
                objects.push(object);
                objectsR.add(object);
            }

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap;
            container.appendChild(renderer.domElement);
            controls = new THREE.TrackballControls(camera, renderer.domElement);
            controls.rotateSpeed = 5.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;
            controls.noZoom = false;
            controls.enablePan = false;
            controls.dynamicDampingFactor = 0.3;
            var box = new THREE.Box3().setFromObject(objectsR);
            var size = box.getSize(new THREE.Vector3()).length();
            var center = box.getCenter(new THREE.Vector3());
            //controls.target.set(center.x, center.y, center.z);
            // dragControls = new THREE.DragControls(objects, camera, renderer.domElement);
            controls.enabled = false;
            // dragControls.addEventListener('dragstart', function () {
            //     controls.enabled = t.visible && selectedObject==null;
            // });
            // dragControls.addEventListener('dragend', function () {
            //     controls.enabled = false;
            //     box = new THREE.Box3().setFromObject(objectsR);
            //     size = box.getSize(new THREE.Vector3());
            //     center = box.getCenter(new THREE.Vector3());
            //     controls.target.set(center.x, center.y, center.z);
            //     // t.position.x = center.x;
            //     // t.position.y = center.y;
            //     // t.position.z = center.z;
            //     // let bola = new THREE.Sphere();
            //     // box.getBoundingSphere(bola);
            //     // t.scale.x = bola.radius / 50;
            //     // t.scale.y = bola.radius / 50;
            //     // t.scale.z = bola.radius / 50;
            // });
            stats = new Stats();
            //window.addEventListener("mousemove", onDocumentMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('dblclick', mouseDBClick);
            window.addEventListener('mousedown', mouseDownEvent);
            window.addEventListener('mouseup', mouseUpEvent);
            window.addEventListener('mousemove', mouseMoveEvent);

        }
        var offset =  new THREE.Vector3();
        var firstclickpoint = new THREE.Vector3();

        function mouseDownEvent(event){
            // Get mouse position
            if(!t.visible){
                var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                // Get 3D vector from 3D mouse position using 'unproject' function
                var vector = new THREE.Vector3(mouseX, mouseY, 1);
                vector.unproject(camera);
                // Set the raycaster position
                raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
                // Find all intersected objects
                var intersects = raycaster.intersectObjects(objects);
                if (intersects.length > 0) {
                    // Disable the controls
                    controls.enabled = false;
                    // Set the selection - first intersected object
                    selectedObjectToDrag = intersects[0].object;
                    // Calculate the offset
                    var intersects = raycaster.intersectObject(plane);
                    offset.copy(intersects[0].point).sub(plane.position);
                }
            }
        }

        function mouseUpEvent(event){
            //controls.enabled = true;
            selectedObjectToDrag = null;
        }

        function mouseMoveEvent(event){
            if(!t.visible){
                //objectsR.rotation.x += 0.005;
                event.preventDefault();
                // Get mouse position
                var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                // Get 3D vector from 3D mouse position using 'unproject' function
                var vector = new THREE.Vector3(mouseX, mouseY, 1);
                vector.unproject(camera);
                // Set the raycaster position
                raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
                if (selectedObjectToDrag) {
                    // Check the position where the plane is intersected
                    var intersects = raycaster.intersectObject(plane);
                    // Reposition the object based on the intersection point with the plane
                    selectedObjectToDrag.position.copy(intersects[0].point.sub(offset));
                } else {
                    // Update position of the plane if need
                    var intersects = raycaster.intersectObjects(objects);
                    if (intersects.length > 0) {
                        plane.position.copy(intersects[0].object.position);
                        plane.lookAt(camera.position);
                    }
                }
            } else {
                //.DefaultUp = new THREE.Vector3( 0, 1, 0 );
                if(selectedObject){
                    ///objectsR.rotation.z += 0.005;
                    console.log("Click", firstclickpoint);
                    box = new THREE.Box3().setFromObject(selectedObject);
                    center = box.getCenter(new THREE.Vector3());
                    console.log("Centro", center);
                    var material = new THREE.LineBasicMaterial({
                        color: 0x0000ff
                    });

                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(
                        center,
                        firstclickpoint
                    );

                    var line = new THREE.Line( geometry, material );
                    scene.add( line );
                }
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        //
        function animate() {
            requestAnimationFrame(animate);
            render();
            stats.update();
        }
        function render() {
            controls.update();
            renderer.render(scene, camera);
        }



        function mouseDBClick(event) {
            //controls.enabled = false;
            event.preventDefault();
            // if (selectedObject) {
            //     selectedObject = null;
            // }
            var intersects = getIntersects(event.layerX, event.layerY);
            if (intersects.length > 0) {
                var res = intersects.filter(function (res) {
                    return res && res.object;
                })[0];
                if (res && res.object) {
                    if (selectedObject == res.object) {
                        t.visible = false;
                        selectedObject = null;
                    } else {
                        selectedObject = res.object;
                        box = new THREE.Box3().setFromObject(selectedObject)
                        size = box.getSize(new THREE.Vector3());
                        center = box.getCenter(new THREE.Vector3());
                        t.position.x = center.x;
                        t.position.y = center.y;
                        t.position.z = center.z;
                        let bola = new THREE.Sphere();
                        box.getBoundingSphere(bola);
                        t.scale.x = bola.radius / 50;
                        t.scale.y = bola.radius / 50;
                        t.scale.z = bola.radius / 50;
                        t.visible = true;

                    }
                }
            } else {
                box = new THREE.Box3().setFromObject(objectsR);
                size = box.getSize(new THREE.Vector3());
                center = box.getCenter(new THREE.Vector3());
                //controls.target.set(center.x, center.y, center.z);
                t.position.x = center.x;
                t.position.y = center.y;
                t.position.z = center.z;
                let bola = new THREE.Sphere();
                box.getBoundingSphere(bola);
                t.scale.x = bola.radius / 50;
                t.scale.y = bola.radius / 50;
                t.scale.z = bola.radius / 50;
                t.visible = t.visible?false:true;
                controls.enabled = t.visible;
                // objectsR.position.x = center.x;
                // objectsR.position.y = center.y;
                // objectsR.position.z = center.z;
            }
            var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            // Get 3D vector from 3D mouse position using 'unproject' function
            firstclickpoint = new THREE.Vector3(mouseX, mouseY, 1);
            //dragControls.enabled = !t.visible;
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            //let color = "#000";
            if (selectedObject) {
                //selectedObject.material.color.set(color);
                //selectedObject.material.color.set('#69f');
                //console.log(1);
                selectedObject = null;
            }
            var intersects = getIntersects(event.layerX, event.layerY);
            if (intersects.length > 0) {
                var res = intersects.filter(function (res) {
                    return res && res.object;
                })[0];
                if (res && res.object) {
                    selectedObject = res.object;
                    //console.log(2);
                }
            }
        }
        var raycaster = new THREE.Raycaster();
        var mouseVector = new THREE.Vector3();
        function getIntersects(x, y) {

            x = (x / window.innerWidth) * 2 - 1;
            y = - (y / window.innerHeight) * 2 + 1;
            mouseVector.set(x, y, 0.5);
            raycaster.setFromCamera(mouseVector, camera);
            return raycaster.intersectObject(objectsR, true);
        }

        function rotateAboutPoint(obj, point, axis, theta, pointIsWorld){
            pointIsWorld = (pointIsWorld === undefined)? false : pointIsWorld;

            if(pointIsWorld){
                obj.parent.localToWorld(obj.position); // compensate for world coordinate
            }

            obj.position.sub(point); // remove the offset
            obj.position.applyAxisAngle(axis, theta); // rotate the POSITION
            obj.position.add(point); // re-add the offset

            if(pointIsWorld){
                obj.parent.worldToLocal(obj.position); // undo world coordinates compensation
            }

            obj.rotateOnAxis(axis, theta); // rotate the OBJECT
        }
    </script>

</body>

</html>
