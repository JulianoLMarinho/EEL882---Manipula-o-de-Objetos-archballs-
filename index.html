<!DOCTYPE html>
<html lang="en">

<head>
    <title>ARCBALLS</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        body {
            background-color: #f0f0f0;
            color: #444;
        }

        a {
            color: #08f;
        }
    </style>
</head>

<body>


    <script src="js/three.js"></script>

    <script src="js/DragControls.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/BufferGeometryUtils.js"></script>


    <script>


        var container, stats;
        var camera, controls, scene, renderer, dragControls;
        var objects = [];
        var objectsR = new THREE.Group();
        objectsR.name = "teste";
        let sphere = new THREE.SphereGeometry(50, 32, 32);
        let material = new THREE.MeshLambertMaterial({ color: Math.random() * 0x000 })
        let t = new THREE.Mesh(sphere, material);
        t.visible = false;
        material.transparent = true;
        material.opacity = 0.3;
        var selectedObject = null;
        var selectedObjectToDrag = null;
        var plane = null;
        init();
        animate();
        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.z = 1000;
            scene = new THREE.Scene();
            plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(5000, 5000, 8, 8), new THREE.MeshBasicMaterial({color: 0xffffff, opacity: 0.0, transparent:true}));
            //plane.visible = false;
            scene.add(plane);
            scene.add(objectsR);
            objectsR.add(t);
            // objects.push(t);
            scene.background = new THREE.Color(0xf0f0f0);
            scene.add(new THREE.AmbientLight(0x505050));
            var light = new THREE.SpotLight(0xffffff, 1.5);
            light.position.set(0, 500, 2000);
            light.angle = Math.PI / 9;
            light.castShadow = true;
            light.shadow.camera.near = 1000;
            light.shadow.camera.far = 4000;
            light.shadow.mapSize.width = 1024;
            light.shadow.mapSize.height = 1024;
            scene.add(light);
            var geometry = new THREE.BoxBufferGeometry(40, 40, 40);
            for (var i = 0; i < 1; i++) {
                var object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                // object.position.x = Math.random() * 500;
                // object.position.y = Math.random() * 500;
                //object.position.z = Math.random() * 250;
                object.rotation.x = Math.random() * 2 * Math.PI;
                object.rotation.y = Math.random() * 2 * Math.PI;
                object.rotation.z = Math.random() * 2 * Math.PI;
                object.scale.x = Math.random() * 5 + 1;
                object.scale.y = Math.random() * 5 + 1;
                object.scale.z = Math.random() * 5 + 1;
                // var axesHelper = new THREE.AxesHelper( 500 );
                // objectsR.add(axesHelper);
                //object.castShadow = true;
                //object.receiveShadow = true;
                objects.push(object);
                objectsR.add(object);
            }

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap;
            container.appendChild(renderer.domElement);
            controls = new THREE.TrackballControls(camera, renderer.domElement);
            controls.rotateSpeed = 5.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;
            controls.noZoom = false;
            controls.enablePan = false;
            controls.dynamicDampingFactor = 0.3;
            var box = new THREE.Box3().setFromObject(objectsR);
            var size = box.getSize(new THREE.Vector3()).length();
            var center = box.getCenter(new THREE.Vector3());
            //controls.target.set(center.x, center.y, center.z);
            dragControls = new THREE.DragControls(objects, camera, renderer.domElement);

            controls.enabled = false;
            // dragControls.addEventListener('dragstart', function () {
            //     controls.enabled = t.visible && selectedObject==null;
            // });
            // dragControls.addEventListener('dragend', function () {
            //     controls.enabled = false;
            //     box = new THREE.Box3().setFromObject(objectsR);
            //     size = box.getSize(new THREE.Vector3());
            //     center = box.getCenter(new THREE.Vector3());
            //     controls.target.set(center.x, center.y, center.z);
            //     // t.position.x = center.x;
            //     // t.position.y = center.y;
            //     // t.position.z = center.z;
            //     // let bola = new THREE.Sphere();
            //     // box.getBoundingSphere(bola);
            //     // t.scale.x = bola.radius / 50;
            //     // t.scale.y = bola.radius / 50;
            //     // t.scale.z = bola.radius / 50;
            // });
            stats = new Stats();
            //window.addEventListener("mousemove", onDocumentMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('dblclick', mouseDBClick);
            window.addEventListener('mousedown', mouseDownEvent);
            window.addEventListener('mouseup', mouseUpEvent);
            window.addEventListener('mousemove', mouseMoveEvent);


        }
        var offset =  new THREE.Vector3();
        var firstclickpoint = new THREE.Vector3();
        var rotaciona = false;
        function mouseDownEvent(event){

            // Get mouse position
            if(!t.visible){
                var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                // Get 3D vector from 3D mouse position using 'unproject' function
                var vector = new THREE.Vector3(mouseX, mouseY, 1);
                vector.unproject(camera);
                // Set the raycaster position
                raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
                // Find all intersected objects
                // console.log(vector);
                var intersects = raycaster.intersectObjects(objects);
                if (intersects.length > 0) {
                    // Disable the controls
                    controls.enabled = false;
                    // Set the selection - first intersected object
                    selectedObjectToDrag = intersects[0].object;
                    // Calculate the offset
                    var intersects = raycaster.intersectObject(plane);
                    offset.copy(intersects[0].point).sub(plane.position);
                }
            } else {
                var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                // Get 3D vector from 3D mouse position using 'unproject' function
                var vector = new THREE.Vector3(mouseX, mouseY, 1);
                vector.unproject(camera);
                firstclickpoint.copy(getSphereClickPosition(vector, t));
                rotaciona = true;
            }
        }

        function getSphereClickPosition(clientVector, sphere){
            var vec = new THREE.Vector3().copy(clientVector);
            raycaster.set( camera.position, vec.sub( camera.position ).normalize() );
            var intersects = raycaster.intersectObject(sphere);
            return intersects[0].point;
        }

        function mouseUpEvent(event){
            //controls.enabled = true;

            selectedObjectToDrag = null;
            rotaciona = false;
        }
        var oij = 0;
        function mouseMoveEvent(event){
            var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            // Get 3D vector from 3D mouse position using 'unproject' function
            var vector = new THREE.Vector3(mouseX, mouseY, 1);

            if(!t.visible){
                //objectsR.rotation.x += 0.005;
                event.preventDefault();
                // Get mouse position

                vector.unproject(camera);
                // Set the raycaster position
                raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
                if (selectedObjectToDrag) {
                    // Check the position where the plane is intersected
                    var intersects = raycaster.intersectObject(plane);
                    // Reposition the object based on the intersection point with the plane
                    selectedObjectToDrag.position.copy(intersects[0].point.sub(offset));
                } else {
                    // Update position of the plane if need
                    var intersects = raycaster.intersectObjects(objects);
                    if (intersects.length > 0) {
                        plane.position.copy(intersects[0].object.position);
                        plane.lookAt(camera.position);
                    }
                }
            } else {
                //.DefaultUp = new THREE.Vector3( 0, 1, 0 );

                if(selectedObject){
                    ///objectsR.rotation.z += 0.005;
                    // console.log("Click", firstclickpoint);
                    box = new THREE.Box3().setFromObject(selectedObject);
                    center = t.position;
                    // console.log("Centro", center);
                    var material = new THREE.LineBasicMaterial({
                        color: 0x0000ff
                    });
                    //console.log(selectedObject.getWorldPosition());
                    // var t3 = new THREE.Vector3();
                    // t3.x = firstclickpoint.x - center.x;
                    // t3.y = firstclickpoint.y - center.y;
                    // t3.z = firstclickpoint.z - center.z;
                    //
                    // //console.log(vector.unproject(camera));
                    // t3.normalize();
                    vector.unproject(camera);

                    // var t2 = new THREE.Vector3();
                    var p = getSphereClickPosition(vector, t);
                    var pcamera = new THREE.Vector3().copy(p);
                    var firstcamera = new THREE.Vector3().copy(firstclickpoint);
                    var hj = new THREE.Vector3();

                    pcamera.sub(center);
                    firstcamera.sub(center);
                    // console.log(p);

                    if(rotaciona){
                        hj.crossVectors(firstcamera,pcamera);
                        //hj.add(center);
                        // console.log(hj);
                        //console.log("angle", p.angleTo(firstclickpoint));
                        // console.log(event);
                        // console.log("first", t3);
                        // console.log("center", center);
                        // console.log("vector", vector);
                        // console.log(p.angleTo(firstclickpoint));
                        var geometry = new THREE.Geometry();
                        geometry.vertices.push(

                            center,
                            new THREE.Vector3().copy(firstcamera).add(center)
                        );

                        var line = new THREE.Line( geometry, material );
                        console.log(selectedObject);
                        scene.add( line );

                        selectedObject.rotateOnWorldAxis(hj.normalize() , firstcamera.angleTo(pcamera));
                        // for(var obj in selectedObject.children){
                        //     obj.position.rotateOnWorldAxis((hj, -firstcamera.angleTo(pcamera)))
                        // }
                        // console.log(hj);
                        //t.rotateOnWorldAxis(hj, firstclickpoint.angleTo(p));
                    }

                    oij++;
                    firstclickpoint = p;
                    // console.log(hj);
                    //console.log(p.project(camera));
                    var geometry = new THREE.Geometry();
                    var l = new THREE.Vector3();
                    //selectedObject.getWorldPosition(l);
                    // console.log("objewto",l);
                    // console.log("esfera", center);
                    // geometry.vertices.push(
                    //     center,
                    //     p
                    // );
                    //
                    // var line = new THREE.Line( geometry, material );
                    // // console.log(line);
                    // scene.add( line );
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        //
        function animate() {
            requestAnimationFrame(animate);
            render();
            stats.update();
        }
        function render() {
            controls.update();
            renderer.render(scene, camera);
        }



        function mouseDBClick(event) {
            event.preventDefault();

            if(t.visible){
                t.visible = false;
                t.radius = 0;
                t.scale = new THREE.Vector3(0,0,0);
                dragControls.enabled = true;
            } else {
                dragControls.enabled = false;
                var intersects = getIntersects(event.layerX, event.layerY);
                if (intersects.length > 0) {
                    var res = intersects.filter(function (res) {
                        return res && res.object;
                    })[0];
                    if (res && res.object) {
                        if (selectedObject == res.object) {
                            t.visible = false;
                            t.scale = new THREE.Vector3(0,0,0);
                            selectedObject = null;
                        } else {
                            selectedObject = res.object;
                            box = new THREE.Box3().setFromObject(selectedObject)
                            size = box.getSize(new THREE.Vector3());
                            center = box.getCenter(new THREE.Vector3());
                            t.position.x = center.x;
                            t.position.y = center.y;
                            t.position.z = center.z;
                            let bola = new THREE.Sphere();

                            box.getBoundingSphere(bola);
                            //t.position = bola.position;
                            t.scale.x = bola.radius / 50;
                            t.scale.y = bola.radius / 50;
                            t.scale.z = bola.radius / 50;
                            t.visible = true;

                        }
                    }
                } else {
                    box = new THREE.Box3().setFromObject(objectsR);
                    selectedObject = objectsR;
                    size = box.getSize(new THREE.Vector3());
                    center = box.getCenter(new THREE.Vector3());
                    //controls.target.set(center.x, center.y, center.z);
                    t.position.x = center.x;
                    t.position.y = center.y;
                    t.position.z = center.z;
                    let bola = new THREE.Sphere();
                    box.getBoundingSphere(bola);
                    // t.scale.x = bola.radius / 50;
                    // t.scale.y = bola.radius / 50;
                    // t.scale.z = bola.radius / 50;
                    t.visible = t.visible?false:true;
                    if(!t.visible){
                        t.scale = new THREE.Vector3(0,0,0);

                    }
                    //controls.enabled = t.visible;
                    // objectsR.position.x = center.x;
                    // objectsR.position.y = center.y;
                    // objectsR.position.z = center.z;
                }
                var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                // Get 3D vector from 3D mouse position using 'unproject' function
                //firstclickpoint = new THREE.Vector3(mouseX, mouseY, 1);
                //dragControls.enabled = !t.visible;
            }
            // if (selectedObject) {
            //     selectedObject = null;
            // }

        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            //let color = "#000";
            if (selectedObject) {
                //selectedObject.material.color.set(color);
                //selectedObject.material.color.set('#69f');
                //console.log(1);
                selectedObject = null;
            }
            var intersects = getIntersects(event.layerX, event.layerY);
            if (intersects.length > 0) {
                var res = intersects.filter(function (res) {
                    return res && res.object;
                })[0];
                if (res && res.object) {
                    selectedObject = res.object;
                    //console.log(2);
                }
            }
        }
        var raycaster = new THREE.Raycaster();
        var mouseVector = new THREE.Vector3();
        function getIntersects(x, y) {

            x = (x / window.innerWidth) * 2 - 1;
            y = - (y / window.innerHeight) * 2 + 1;
            mouseVector.set(x, y, 0.5);
            raycaster.setFromCamera(mouseVector, camera);
            return raycaster.intersectObject(objectsR, true);
        }

        function rotateAboutPoint(obj, point, axis, theta, pointIsWorld){
            pointIsWorld = (pointIsWorld === undefined)? false : pointIsWorld;

            if(pointIsWorld){
                obj.parent.localToWorld(obj.position); // compensate for world coordinate
            }

            obj.position.sub(point); // remove the offset
            obj.position.applyAxisAngle(axis, theta); // rotate the POSITION
            obj.position.add(point); // re-add the offset

            if(pointIsWorld){
                obj.parent.worldToLocal(obj.position); // undo world coordinates compensation
            }

            obj.rotateOnAxis(axis, theta); // rotate the OBJECT
        }
    </script>

</body>

</html>
